# Секция receivers (приемники) описывает, откуда OpenTelemetry Collector получает данные телеметрии
receivers:
  # OTLP (OpenTelemetry Protocol) - стандартный протокол для передачи телеметрии
  # Используется для приема данных от инструментированных приложений
  otlp:
    protocols:
      # gRPC протокол - бинарный протокол на основе HTTP/2, обеспечивает высокую производительность
      grpc:
        # Адрес, на котором коллектор слушает gRPC соединения
        # 0.0.0.0 означает "все сетевые интерфейсы"
        endpoint: 0.0.0.0:4317

# Секция processors (обработчики) описывает, как обрабатывать полученные данные
# перед отправкой их в экспортеры
processors:
  # RESOURCE PROCESSOR - обогащение метаданными на уровне ресурса
  resource:
    attributes:
      # НЕ переопределяем service.name в коллекторе, чтобы поддерживать несколько сервисов
      # Каждый сервис должен задавать service.name на стороне приложения

      # DEPLOYMENT ENVIRONMENT: окружение развертывания
      # Помогает различать логи из dev/staging/production
      - key: deployment.environment
        value: dev
        action: insert # добавляем только если атрибут не задан приложением

  # Батчинг - группировка данных в пакеты для эффективной передачи
  batch:
    # Максимальный размер пакета (количество элементов)
    send_batch_size: 1000
    # Максимальное время ожидания перед отправкой неполного пакета
    timeout: 10s
    # Максимальное кол-во отправляемых элементов за один раз
    send_batch_max_size: 1000

  # Вероятностное семплирование - этот процессор управляет объемом собираемых данных
  # Применяется только к трейсам в соответствующем пайплайне
  probabilistic_sampler:
    # Процент трейсов, которые будут сохранены
    # 100% означает сохранение всех данных (хорошо для разработки)
    # В продакшене рекомендуется более низкий процент (1-10%) для снижения нагрузки
    sampling_percentage: 100

# Секция exporters (экспортеры) описывает, куда отправлять обработанные данные телеметрии
exporters:
  # Экспорт трейсов в Jaeger
  otlp/jaeger:
    endpoint: jaeger:4317 # Эндпоинт Jaeger, принимающий OTLP формат
    # Коллектор отправляет данные в Jaeger по gRPC
    # Jaeger слушает на порту 4317 для приема данных от коллектора
    tls:
      insecure: true # Отключение TLS для локальной разработки

  # Экспорт данных в логи - полезно для отладки
  debug:
    # Уровень детализации логов
    verbosity: detailed

  # ELASTICSEARCH EXPORTER - отправка логов в Elasticsearch
  elasticsearch:
    # ENDPOINTS: список адресов Elasticsearch кластера
    # В production обычно несколько узлов для отказоустойчивости
    endpoints: ["http://elasticsearch:9200"]

    # TLS НАСТРОЙКИ: конфигурация безопасного соединения
    tls:
      # INSECURE: отключаем проверку сертификатов для локальной разработки
      # В production ОБЯЗАТЕЛЬНО включить проверку сертификатов
      insecure: true

      # ДОПОЛНИТЕЛЬНЫЕ TLS НАСТРОЙКИ (для production):
      # cert_file: "/path/to/cert.pem"     # путь к сертификату клиента
      # key_file: "/path/to/key.pem"       # путь к приватному ключу
      # ca_file: "/path/to/ca.pem"         # путь к CA сертификату

    # LOGS INDEX: имя индекса для хранения логов в Elasticsearch
    # Все логи будут сохраняться в индекс "easy-logs"
    # Можно использовать шаблоны: "logs-%{+yyyy.MM.dd}" для создания daily индексов
    logs_index: "easy-logs"

    # MAPPING: настройки индексации данных
    mapping:
      # ECS MODE: использовать Elastic Common Schema
      # Стандартизирует структуру полей логов для лучшей совместимости
      mode: ecs

      # ECS обеспечивает:
      # - @timestamp: временная метка лога
      # - message: текст сообщения
      # - event.severity: уровень логирования
      # - service.name: имя сервиса
      # - и другие стандартизированные поля

    # ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ (можно добавить):
    # retry:
    #   enabled: true               # включить повторные попытки
    #   max_requests: 5             # максимум попыток
    #   initial_interval: 100ms     # начальная задержка
    # timeout: 90s                  # таймаут HTTP запроса
    # compression: gzip             # сжатие данных

extensions:
  # HEALTH CHECK: эндпоинт проверки здоровья коллектора - Полезно для мониторинга в Kubernetes/Docker
  health_check:
    endpoint: 0.0.0.0:13133
    # Доступные эндпоинты:
    # - GET /health/status - общий статус
    # - GET /health/ready  - готовность к работе

# Секция service описывает, как компоненты (receivers, processors, exporters)
# соединяются вместе в рабочие пайплайны
service:
  # Настройки телеметрии для самого коллектора (метрики + healthcheck)
  telemetry:
    metrics:
      address: 0.0.0.0:8888 # Prometheus метрики для мониторинга и healthcheck

  # Определение пайплайнов для разных типов телеметрии
  pipelines:
    # Пайплайн для трейсов
    traces:
      receivers: [otlp] # принимаем от OTLP gRPC
      # ВАЖНО: сначала семплируем (отбрасываем лишние), потом батчуем (группируем нужные)
      processors: [probabilistic_sampler, batch]
      exporters: [otlp/jaeger, debug] # отправляем в jaeger и debug

    # Пайплайн для логов
    logs:
      # ПОСЛЕДОВАТЕЛЬНОСТЬ ОБРАБОТКИ: receivers → processors → exporters
      receivers: [otlp] # принимаем от OTLP gRPC
      processors: [resource, batch] # обогащаем метаданными, группируем в батчи
      exporters: [elasticsearch] # отправляем в Elasticsearch
